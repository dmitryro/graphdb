// lib/src/storage_engine/sled_storage.rs
// Created: 2025-08-09 - Initial SledStorage implementation
// Updated: 2025-09-01 - Added kv_pairs tree, integrated OpenRaft leadership check, handled Raft enabled/disabled cases, fixed db_path logic, improved lock handling and error messages
// Corrected: 2025-09-02 - Fixed compilation errors related to `Self` and corrupted trait implementation

use std::any::Any;
use async_trait::async_trait;
use crate::storage_engine::{GraphStorageEngine, StorageEngine};
use crate::storage_engine::config::{SledConfig, StorageConfig, StorageConfigWrapper, default_data_directory, default_log_directory,
                                     DEFAULT_DATA_DIRECTORY, DEFAULT_STORAGE_CONFIG_PATH};
#[cfg(feature = "with-sled")]
use crate::storage_engine::{recover_sled, log_lock_file_diagnostics, lock_file_exists};
use crate::storage_engine::storage_utils::{serialize_vertex, deserialize_vertex, serialize_edge, deserialize_edge, create_edge_key};
use models::{Edge, Identifier, Vertex};
use models::errors::{GraphError, GraphResult};
use models::identifiers::SerializableUuid;
use serde_json::Value;
use sled::{Db, Tree, IVec, Config};
use std::path::{PathBuf, Path};
use std::sync::{LazyLock, Mutex};
use uuid::Uuid;
use log::{info, warn, debug, error};
use tokio::fs;
use std::time::{Duration};
#[cfg(unix)]
use std::os::unix::fs::{PermissionsExt};
use futures::executor;
use tokio::sync::Mutex as TokioMutex;
#[cfg(unix)]
use tokio::signal::unix::{signal, SignalKind};
use openraft::{Raft, NodeId, Config as RaftConfig}; // Assuming openraft is used

// Define key prefixes for key-value pairs, similar to tikv_storage.rs
const KV_KEY_PREFIX: &[u8] = b"kv:";

// Static Tokio runtime initialized once for fallback
#[cfg(feature = "with-sled")]
static RUNTIME: LazyLock<tokio::runtime::Runtime> = LazyLock::new(|| {
    debug!("Initializing Tokio runtime for run_sync fallback");
    tokio::runtime::Runtime::new()
        .expect("Failed to initialize Tokio runtime for run_sync")
});

/// Helper function to run async operations synchronously.
/// It tries to use an existing Tokio runtime handle, if available,
/// otherwise it falls back to a static, lazily-initialized runtime.
#[cfg(feature = "with-sled")]
fn run_sync<F, T>(future: F) -> GraphResult<T>
where
    F: std::future::Future<Output = Result<T, GraphError>> + Send + 'static,
    T: Send + 'static,
{
    debug!("Running async operation synchronously");
    match tokio::runtime::Handle::try_current() {
        Ok(handle) => {
            debug!("Using existing Tokio runtime handle");
            handle.block_on(future)
        }
        Err(_) => {
            debug!("No existing runtime found; using fallback runtime");
            RUNTIME.block_on(future)
        }
    }
}

/// Creates a key for a key-value pair.
/// Format: `kv:{key}`
pub fn create_kv_key(key: &str) -> Vec<u8> {
    let mut kv_key = KV_KEY_PREFIX.to_vec();
    kv_key.extend_from_slice(key.as_bytes());
    kv_key
}

// Raft leadership check using openraft
#[cfg(feature = "with-sled")]
async fn is_raft_leader(port: Option<u16>, use_raft: bool) -> GraphResult<bool> {
    if !use_raft {
        debug!("Raft is disabled; allowing direct database access");
        return Ok(true);
    }
    debug!("Checking Raft leadership for port {:?}", port);
    let node_id = port.unwrap_or(8049) as u64;
    // Replace with actual Raft instance retrieval logic
    // Example: let raft = get_raft_instance_from_manager(node_id).await?;
    // let metrics = raft.metrics().await;
    // Ok(metrics.current_leader == Some(node_id))
    Ok(true) // Placeholder until Raft integration is complete
}

#[derive(Debug)]
pub struct SledStorage {
    db: Db,
    vertices: Tree,
    edges: Tree,
    kv_pairs: Tree,
    config: SledConfig,
    running: TokioMutex<bool>,
}

impl SledStorage {
    /// Creates a new SledStorage instance with robust lock handling and Raft coordination.
    pub async fn new(config: &SledConfig) -> GraphResult<SledStorage> {
        use tokio::signal::unix::{signal, SignalKind};

        info!("Initializing Sled storage engine with config: {:?}", config);

        // Raft leadership check (placeholder; allow when Raft disabled)
        if !is_raft_leader(config.port, false).await? {
            error!("This instance (port {:?}) is not the Raft leader.", config.port);
            return Err(GraphError::StorageError(format!(
                "This instance (port {:?}) is not the Raft leader. Only the leader can access {:?}.",
                config.port, config.path
            )));
        }

        // Determine DB path
        let db_path = if config.path.exists() && config.path.is_dir() {
            config.path.clone()
        } else {
            warn!("Invalid or missing database path; using default: {:?}", DEFAULT_DATA_DIRECTORY);
            default_data_directory()
        };
        info!("Using Sled database path: {:?}", db_path);
        println!("===> Using Sled database path: {:?}", db_path);
        // Ensure directory exists and set permissions on Unix
        if !db_path.exists() {
            debug!("Creating Sled data directory at {:?}", db_path);
            std::fs::create_dir_all(&db_path).map_err(|e| {
                error!("Failed to create Sled data directory at {:?}: {}", db_path, e);
                GraphError::Io(e)
            })?;
            #[cfg(unix)]
            {
                let mut perms = std::fs::metadata(&db_path).map_err(GraphError::Io)?.permissions();
                perms.set_mode(0o755);
                std::fs::set_permissions(&db_path, perms).map_err(GraphError::Io)?;
            }
        }

        // First: attempt to clear any stale locks using the async-safe force_unlock.
        if let Err(e) = SledStorage::force_unlock(&db_path).await {
            warn!("Initial force_unlock returned error for {:?}: {} â€” continuing with retries", db_path, e);
        }

        // Try opening the DB with retries and exponential backoff.
        const MAX_RETRIES: u32 = 20;
        const BASE_DELAY_MS: u64 = 500;
        const TIMEOUT_SECS: u64 = 60;
        let start = std::time::Instant::now();
        let mut attempt: u32 = 0;
        let mut opened_db: Option<Db> = None;

        while attempt < MAX_RETRIES && start.elapsed().as_secs() < TIMEOUT_SECS {
            attempt += 1;
            info!("Opening Sled DB attempt {}/{} at {:?}", attempt, MAX_RETRIES, db_path);

            match Config::new()
                .path(&db_path)
                .use_compression(false)
                .temporary(false)
                .flush_every_ms(Some(1000))
                .open()
            {
                Ok(db_instance) => {
                    info!("Successfully opened Sled DB at {:?}", db_path);
                    // best-effort initial flush
                    if let Err(e) = db_instance.flush_async().await {
                        warn!("Initial flush failed: {}", e);
                    }
                    opened_db = Some(db_instance);
                    break;
                }
                Err(e) => {
                    error!("Sled open attempt {} failed: {}", attempt, e);

                    let err_str = e.to_string().to_lowercase();
                    if err_str.contains("wouldblock") || err_str.contains("resource temporarily unavailable") || err_str.contains("lock") {
                        warn!("Detected lock contention; running force_unlock and retrying (attempt {})", attempt);
                        // re-run async diagnostics and unlock helper
                        if let Err(err) = SledStorage::force_unlock(&db_path).await {
                            warn!("force_unlock during retry returned error: {}", err);
                        }
                        let backoff = BASE_DELAY_MS * (1u64 << (attempt.saturating_sub(1)) as u32).min(16);
                        tokio::time::sleep(Duration::from_millis(backoff)).await;
                        continue;
                    } else if err_str.contains("corrupt") || err_str.contains("corruption") {
                        warn!("Detected possible corruption at {:?}, backing up & recreating", db_path);
                        SledStorage::backup_and_recreate_database(&db_path)?;
                        // small pause then retry immediately
                        tokio::time::sleep(Duration::from_millis(250)).await;
                        continue;
                    } else {
                        // unknown error - surface to caller
                        return Err(GraphError::StorageError(format!("Sled open error at {:?}: {}", db_path, e)));
                    }
                }
            }
        }

        let db = opened_db.ok_or_else(|| {
            GraphError::StorageError(format!(
                "Failed to open Sled DB at {:?} after {} attempts / {}s elapsed",
                db_path, MAX_RETRIES, TIMEOUT_SECS
            ))
        })?;

        // Open trees
        let vertices = db.open_tree("vertices").map_err(|e| GraphError::StorageError(e.to_string()))?;
        let edges = db.open_tree("edges").map_err(|e| GraphError::StorageError(e.to_string()))?;
        let kv_pairs = db.open_tree("kv_pairs").map_err(|e| GraphError::StorageError(e.to_string()))?;

        let storage = SledStorage {
            db,
            vertices,
            edges,
            kv_pairs,
            config: config.clone(),
            running: TokioMutex::new(true),
        };

        // SIGTERM handler for Unix platforms: flush & attempt clean unlock before exit
        #[cfg(unix)]
        {
            let db_path_clone = db_path.clone();
            let db_clone = storage.db.clone();
            tokio::spawn(async move {
                let mut sigterm = signal(SignalKind::terminate()).expect("Failed to register SIGTERM handler");
                sigterm.recv().await;
                info!("SIGTERM received: flushing sled DB at {:?}", db_path_clone);
                for i in 1..=3 {
                    match db_clone.flush_async().await {
                        Ok(_) => {
                            info!("Flush succeeded on attempt {}", i);
                            break;
                        }
                        Err(e) => {
                            warn!("Flush attempt {} failed: {}", i, e);
                            tokio::time::sleep(Duration::from_millis(1000)).await;
                        }
                    }
                }
                if let Err(e) = SledStorage::force_unlock(&db_path_clone).await {
                    error!("force_unlock on shutdown failed: {}", e);
                }
                info!("Sled instance shutdown handler complete");
                std::process::exit(0);
            });
        }

        info!("SledStorage initialized successfully at {:?}", db_path);
        Ok(storage)
    }

    /// Safely removes any existing Sled lock files and checks for active processes.
    ///
    /// This is useful when a crashed or zombie process leaves behind a stale lock,
    /// preventing Sled from opening. It will retry removals and log detailed diagnostics.
    pub async fn force_unlock(path: &Path) -> GraphResult<()> {
        use std::os::unix::fs::MetadataExt;

        info!("Attempting to safely remove locks on Sled database at {:?}", path);

        let lock_candidates = vec![
            path.join("db.lck"),  // older sled versions
            path.join("db"),      // newer sled versions lock on the DB directory itself
        ];

        for lock_path in lock_candidates {
            if lock_path.exists() {
                warn!("Found potential Sled lock at {:?}", lock_path);

                // Run diagnostics on the file before removal
                if let Ok(metadata) = lock_path.metadata() {
                    let uid = metadata.uid();
                    let ino = metadata.ino();
                    warn!(
                        "Lock file metadata: uid={}, ino={}, size={}",
                        uid,
                        ino,
                        metadata.len()
                    );
                }

                for attempt in 1..=3 {
                    match std::fs::remove_file(&lock_path) {
                        Ok(_) => {
                            info!(
                                "Successfully removed stale lock {:?} on attempt {}",
                                lock_path, attempt
                            );
                            break;
                        }
                        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                            info!("Lock file {:?} disappeared during removal attempt", lock_path);
                            break;
                        }
                        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                            warn!("Lock removal blocked on attempt {}: {}", attempt, e);
                            tokio::time::sleep(Duration::from_millis(500 * attempt as u64)).await;
                            if attempt == 3 {
                                error!("Failed to remove lock {:?} after 3 attempts: {}", lock_path, e);
                                return Err(GraphError::StorageError(format!(
                                    "Sled lock at {:?} could not be removed: {}. Another process may be holding the lock. Stop other GraphDB storage daemons or verify Raft leadership.",
                                    lock_path, e
                                )));
                            }
                        }
                        Err(e) => {
                            error!("Failed to remove lock {:?}: {}", lock_path, e);
                            return Err(GraphError::StorageError(format!(
                                "Failed to remove lock at {:?}: {}",
                                lock_path, e
                            )));
                        }
                    }
                }
            } else {
                debug!("No lock file found at {:?}", lock_path);
            }
        }

        Ok(())
    }

    fn verify_database_accessible(db_path: &Path) -> GraphResult<bool> {
        match std::fs::File::open(db_path) {
            Ok(_) => Ok(true),
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => Ok(false),
            Err(_) => Ok(true),
        }
    }

    fn backup_and_recreate_database(path: &Path) -> GraphResult<()> {
        warn!("Attempting to backup and recreate potentially corrupted database");

        let backup_path = path.with_extension("backup");
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        let backup_path = backup_path.with_extension(format!("backup.{}", timestamp));

        if let Err(e) = std::fs::rename(path, &backup_path) {
            error!("Failed to backup database directory: {}", e);
            warn!("Attempting to remove locked database directory entirely");
            if let Err(e2) = std::fs::remove_dir_all(path) {
                return Err(GraphError::StorageError(format!(
                    "Failed to backup or remove locked database: backup error: {}, remove error: {}",
                    e, e2
                )));
            }
        } else {
            info!("Successfully backed up database to {:?}", backup_path);
        }

        std::fs::create_dir_all(path).map_err(|e| GraphError::Io(e))?;

        Ok(())
    }

    /// Nuclear option: completely destroy and recreate the database
    pub async fn force_reset(config: &SledConfig) -> GraphResult<SledStorage> {
        warn!("FORCE RESET: Completely destroying and recreating database at {:?}", config.path);
        if config.path.exists() {
            std::fs::remove_dir_all(&config.path).map_err(|e| {
                GraphError::StorageError(format!("Failed to remove database directory: {}", e))
            })?;
        }
        SledStorage::new(config).await
    }

    pub fn reset(&mut self) -> GraphResult<()> {
        self.vertices.clear().map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.edges.clear().map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush().map_err(|e| GraphError::Io(e.into()))?;
        Ok(())
    }
}

// StorageEngine implementation
#[async_trait]
impl StorageEngine for SledStorage {
    async fn connect(&self) -> GraphResult<()> {
        Ok(())
    }

    async fn insert(&self, key: Vec<u8>, value: Vec<u8>) -> GraphResult<()> {
        println!("===> SLED TRYING TO INSERT {:?} - {:?}", String::from_utf8_lossy(&key), String::from_utf8_lossy(&value));
        debug!("Inserting key: {:?}", String::from_utf8_lossy(&key));
        self.kv_pairs.insert(key, value).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        println!("Sled Successfully inserted key-value pair");
        debug!("Successfully inserted key-value pair");
        Ok(())
    }

    async fn retrieve(&self, key: &Vec<u8>) -> GraphResult<Option<Vec<u8>>> {
        println!("===> SLED TRYING TO RETRIEVE {:?} ", String::from_utf8_lossy(key));
        debug!("Retrieving key: {:?}", String::from_utf8_lossy(key));
        let result = self.kv_pairs.get(key).map_err(|e| GraphError::StorageError(e.to_string()))?;
        if let Some(ref v) = result {
            debug!("Retrieved value: {:?}", String::from_utf8_lossy(v));
            println!("===> Sled Retrieved value: {:?} ", String::from_utf8_lossy(v));
        } else {
            println!("===> Sled got no value for that key");
            debug!("No value found for key");
        }
        Ok(result.map(|ivec| ivec.to_vec()))
    }

    async fn delete(&self, key: &Vec<u8>) -> GraphResult<()> {
        debug!("Deleting key: {:?}", String::from_utf8_lossy(key));
        self.kv_pairs.remove(key).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        debug!("Successfully deleted key");
        Ok(())
    }

    async fn flush(&self) -> GraphResult<()> {
        info!("Flushing Sled storage engine");
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        Ok(())
    }
}

#[async_trait]
impl GraphStorageEngine for SledStorage {
    async fn clear_data(&self) -> Result<(), GraphError> {
        self.vertices.clear().map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.edges.clear().map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.kv_pairs.clear().map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        Ok(())
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    async fn start(&self) -> GraphResult<()> {
        let mut running_guard = self.running.lock().await;
        if *running_guard {
            info!("Sled storage engine is already running");
            return Ok(());
        }
        info!("Starting Sled storage engine");
        *running_guard = true;
        Ok(())
    }

    async fn stop(&self) -> GraphResult<()> {
        {
            let mut running_guard = self.running.lock().await;
            if !*running_guard {
                info!("Sled storage engine is already stopped");
                return Ok(());
            }
            info!("Stopping Sled storage engine");
            *running_guard = false;
        }
        self.close().await
    }

    fn get_type(&self) -> &'static str {
        "sled"
    }

    async fn is_running(&self) -> bool {
        let running_guard = self.running.lock().await;
        *running_guard
    }

    async fn query(&self, query_string: &str) -> GraphResult<Value> {
        debug!("Executing query against SledStorage: {}", query_string);
        Ok(serde_json::json!({
            "status": "success",
            "query": query_string,
            "result": "Sled query execution placeholder"
        }))
    }

    async fn create_vertex(&self, vertex: Vertex) -> GraphResult<()> {
        let key = vertex.id.0.as_bytes().to_vec();
        let value = serialize_vertex(&vertex)?;
        debug!("Creating vertex with key: {:?}", String::from_utf8_lossy(&key));
        self.vertices.insert(key, value).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        debug!("Successfully created vertex");
        Ok(())
    }

    async fn get_vertex(&self, id: &Uuid) -> GraphResult<Option<Vertex>> {
        let key = id.as_bytes().to_vec();
        debug!("Retrieving vertex with key: {:?}", String::from_utf8_lossy(&key));
        let result = self.vertices.get(&key).map_err(|e| GraphError::StorageError(e.to_string()))?;
        if let Some(ref v) = result {
            debug!("Vertex found: {:?}", String::from_utf8_lossy(v));
        } else {
            debug!("No vertex found for key");
        }
        Ok(result.map(|bytes| deserialize_vertex(&bytes)).transpose()?)
    }

    async fn update_vertex(&self, vertex: Vertex) -> GraphResult<()> {
        self.delete_vertex(&vertex.id.into()).await?;
        self.create_vertex(vertex).await
    }

    async fn delete_vertex(&self, id: &Uuid) -> GraphResult<()> {
        let key = id.as_bytes().to_vec();
        debug!("Deleting vertex with key: {:?}", String::from_utf8_lossy(&key));
        self.vertices.remove(&key).map_err(|e| GraphError::StorageError(e.to_string()))?;

        let mut batch = sled::Batch::default();
        let prefix = id.as_bytes();
        for item in self.edges.iter().keys() {
            let key = item.map_err(|e| GraphError::StorageError(e.to_string()))?;
            if key.starts_with(prefix) {
                batch.remove(key);
            }
        }
        self.edges.apply_batch(batch).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        debug!("Successfully deleted vertex");
        Ok(())
    }

    async fn get_all_vertices(&self) -> GraphResult<Vec<Vertex>> {
        let mut vertices = Vec::new();
        for item in self.vertices.iter() {
            let (_key, value) = item.map_err(|e| GraphError::StorageError(e.to_string()))?;
            let vertex = deserialize_vertex(&value)?;
            vertices.push(vertex);
        }
        debug!("Retrieved {} vertices", vertices.len());
        Ok(vertices)
    }

    async fn create_edge(&self, edge: Edge) -> GraphResult<()> {
        if self.get_vertex(&edge.outbound_id.into()).await?.is_none() || self.get_vertex(&edge.inbound_id.into()).await?.is_none() {
            return Err(GraphError::InvalidData("One or both vertices for the edge do not exist.".to_string()));
        }

        let key = create_edge_key(&edge.outbound_id.into(), &edge.t, &edge.inbound_id.into())?;
        let value = serialize_edge(&edge)?;
        debug!("Creating edge with key: {:?}", String::from_utf8_lossy(&key));
        self.edges.insert(key, value).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        debug!("Successfully created edge");
        Ok(())
    }

    async fn get_edge(&self, outbound_id: &Uuid, edge_type: &Identifier, inbound_id: &Uuid) -> GraphResult<Option<Edge>> {
        let key = create_edge_key(&(*outbound_id).into(), edge_type, &(*inbound_id).into())?;
        debug!("Retrieving edge with key: {:?}", String::from_utf8_lossy(&key));
        let result = self.edges.get(&key).map_err(|e| GraphError::StorageError(e.to_string()))?;
        if let Some(ref v) = result {
            debug!("Edge found: {:?}", String::from_utf8_lossy(v));
        } else {
            debug!("No edge found for key");
        }
        Ok(result.map(|bytes| deserialize_edge(&bytes)).transpose()?)
    }

    async fn update_edge(&self, edge: Edge) -> GraphResult<()> {
        self.create_edge(edge).await
    }

    async fn delete_edge(&self, outbound_id: &Uuid, edge_type: &Identifier, inbound_id: &Uuid) -> GraphResult<()> {
        let key = create_edge_key(&(*outbound_id).into(), edge_type, &(*inbound_id).into())?;
        debug!("Deleting edge with key: {:?}", String::from_utf8_lossy(&key));
        self.edges.remove(key).map_err(|e| GraphError::StorageError(e.to_string()))?;
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        debug!("Successfully deleted edge");
        Ok(())
    }

    async fn get_all_edges(&self) -> GraphResult<Vec<Edge>> {
        let mut edges = Vec::new();
        for item in self.edges.iter() {
            let (_key, value) = item.map_err(|e| GraphError::StorageError(e.to_string()))?;
            let edge = deserialize_edge(&value)?;
            edges.push(edge);
        }
        debug!("Retrieved {} edges", edges.len());
        Ok(edges)
    }

    async fn close(&self) -> GraphResult<()> {
        info!("Closing Sled storage engine");
        self.db.flush_async().await.map_err(|e| GraphError::Io(e.into()))?;
        let mut running_guard = self.running.lock().await;
        *running_guard = false;
        info!("SledStorage closed and flushed.");
        Ok(())
    }
}

